---
title: 高度な計算列のタイプ
description: ほとんどのユースケースでの列の基本を学びますが、Data Warehouse Manager で作成できるよりも少し複雑な計算列が必要になる場合があります。
exl-id: 9871fa19-95b3-46e4-ae2d-bd7c524d12db
role: Admin, Data Architect, Data Engineer, User
feature: Commerce Tables, Data Warehouse Manager
source-git-commit: 6e2f9e4a9e91212771e6f6baa8c2f8101125217a
workflow-type: tm+mt
source-wordcount: '930'
ht-degree: 2%

---

# 高度な計算列のタイプ

作成する分析の多くには、**定または** 定する `group by` 新しい列 `filter by` の使用が含まれる場合があります。 [ 計算列の作成 ](../data-warehouse-mgr/creating-calculated-columns.md) チュートリアルでは、ほとんどのユースケースの基本を説明しますが、Data Warehouse Manager で作成できるよりも少し複雑な計算列が必要になる場合があります。
{: #top}

これらのタイプの列は、Data Warehouse アナリストのAdobe チームが作成できます。 新しい計算列を定義するには、次の情報を入力します。

1. この列の **`definition`** （入力、式、書式設定を含む）
1. 列を作成する **`table`**
1. 列に何を含めるかを説明する **`example data points`**

ユーザーにとって役に立つ可能性の高い高度な計算列の一般的な例を次に示します。

* [イベントを順番に並べ替える（またはランク付ける）](#compareevents)
* [2 つのイベント間の時間の検索](#twoevents)
* [順次イベント値の比較](#sequence)
* [通貨を換算](#currency)
* [タイムゾーンを変換](#timezone)
* [他の項目](#else)

## イベントを順番に並べ替えようとしています {#compareevents}

これは **イベント番号** 計算列と呼ばれます。 つまり、顧客やユーザーなど、特定のイベント所有者に対してイベントが発生したシーケンスを見つけようとしています。

次に例を示します。

| **`event\_id`** | **`owner\_id`** | **`timestamp`** | **`Owner's event number`** |
|-----|-----|-----|-----|
| 1 | `A` | 2015-01-01 00:00:00 | 1 |
| 2 | `B` | 2015-01-01 00:30:00 | 1 |
| 3 | `A` | 2015-01-01 02:00:00 | 2 |
| 4 | `A` | 2015-01-02 13:00:00 | 3 |
| 5 | `B` | 2015-01-03 13:00:00 | 2 |

{style="table-layout:auto"}

イベント数計算列を使用すると、データの初回イベント、リピートイベントまたは n 番目のイベント間の動作の違いを確認できます。

顧客の注文番号列を実際に表示したいですか？ 画像をクリックして、レポートでグループ化ディメンションとして使用されていることを確認します。

![ イベント番号の計算列を使用して、顧客の注文番号でグループ化。](../../assets/EventNumber.gif)<!--{: style="max-width: 500px;"}-->

このタイプの集計列を作成するには、次の点を理解しておく必要があります。

* この列を作成するテーブル
* イベントの所有者を識別するフィールド（この例では `owner\_id`）
* イベントの並べ替えに使用するフィールド（この例では `timestamp`）

[トップに戻る](#top)

## 私は 2 つの出来事の間の時間を見つけようとしている。 {#twoevents}

これは、`date difference` 計算カラムと呼ばれます。 つまり、イベントのタイムスタンプに基づいて、1 つのレコードに属する 2 つのイベント間の時間を検索しようとしています。

次に例を示します。

| `id` | `timestamp\_1` | `timestamp\_2` | `Seconds between timestamp\_2 and timestamp\_1` |
|-----|-----|-----|-----|
| `A` | 2015-01-01 00:00:00 | 2015-01-01 12:30:00 | 45000 |
| `B` | 2015-01-01 08:00:00 | 2015-01-01 10:00:00 | 7200 |

{style="table-layout:auto"}

日付差計算列を使用すると、2 つのイベント間の平均または中央値の時間を計算する指標を作成できます。 レポートでの `Average time to first order` 指標の使用方法を確認するには、以下の画像をクリックします。

![ 日付差異の計算列を使用して、初回注文までの平均時間を計算します。](../../assets/DateDifference.gif)<!--{: style="max-width: 500px;"}-->

このタイプの集計列を作成するには、次の点を理解しておく必要があります。

* この列を作成するテーブル
* 違いを知りたい 2 つのタイムスタンプ

[トップに戻る](#top)

## 順次イベント値を比較しようとしています。 {#sequence}

これは **順次イベント比較** と呼ばれます。 つまり、値（通貨、数値、タイムスタンプ）と所有者の以前のイベントに対応する値との間のデルタを見つけようとしています。

次に例を示します。

| **`event\_id`** | **`owner\_id`** | **`timestamp`** | **`Seconds since owner's previous event`** |
|-----|-----|-----|-----|
| 1 | `A` | 2015-01-01 00:00:00 | NULL |
| 2 | `B` | 2015-01-01 00:30:00 | NULL |
| 3 | `A` | 2015-01-01 02:00:00 | 7720 |
| 4 | `A` | 2015-01-02 13:00:00 | 126000 |
| 5 | `B` | 2015-01-03 13:00:00 | 217800 |

{style="table-layout:auto"}

順次イベント比較を使用して、各順次イベント間の平均時間または中央値の時間を見つけることができます。 下の画像をクリックして、実行中の **注文間の平均および中央値の時間** 指標を確認します。

=![ 順次イベント比較計算列を使用して注文間の平均および中央値の時間を計算します。](../../assets/SeqEventComp.gif)<!--{: style="max-width: 500px;"}-->

このタイプの集計列を作成するには、次の点を理解しておく必要があります。

* この列を作成するテーブル
* イベントの所有者を識別するフィールド（この例では `owner\_id`）
* 各順次イベントの違いを確認する値フィールド（この例では `timestamp`）

[トップに戻る](#top)

## 私は通貨を換算しようとしています。 {#currency}

**通貨換算** 計算列は、イベント時の為替レートに基づいて、取引金額を記録済の通貨から報告通貨に変換します。

次に例を示します。

| **`id`** | **`timestamp`** | **`transaction\_value\_EUR`** | **`transaction\_value\_USD`** |
|-----|-----|-----|-----|
| `1` | 2015-01-01 00:00:00 | 30 | 33.57 |
| `2` | 2015-01-02 00:00:00 | 50 | 55.93 |

{style="table-layout:auto"}

このタイプの集計列を作成するには、次の点を理解しておく必要があります。

* この列を作成するテーブル
* 変換するトランザクション金額列
* データが記録された通貨を示す列（通常、ISO コード）
* 優先レポート通貨

[トップに戻る](#top)

## タイムゾーンを変換しようとしています。 {#timezone}

**タイムゾーン変換** の計算列では、特定のデータソースのタイムスタンプが、記録されたタイムゾーンからレポートタイムゾーンに変換されます。

次に例を示します。

| **`id`** | **`timestamp\_UTC`** | **`timestamp\_ET`** |
|-----|-----|-----|
| `1` | 2015-01-01 00:00:00 | 2014-12-31 19:00:00 |
| `2` | 2015-01-01 12:00:00 | 2015-01-01 07:00:00 |

{style="table-layout:auto"}

このタイプの集計列を作成するには、次の点を理解しておく必要があります。

* この列を作成するテーブル
* 変換するタイムスタンプ列
* データが記録されたタイムゾーン
* 優先するレポートタイムゾーン

[トップに戻る](#top)

## ここに記載されていない操作を実行しようとしています。 {#else}

心配しないでください。 ここに記載されていないからといって、不可能という意味ではありません。 Data Warehouse アナリストのAdobe チームがお手伝いします。

新しい計算列を定義するには、作成する内容に正確な詳細を指定して [ サポートチケットを送信 ](https://experienceleague.adobe.com/docs/commerce-knowledge-base/kb/troubleshooting/miscellaneous/mbi-service-policies.html?lang=ja) します。

## 関連ドキュメント

* [計算列の作成](../data-warehouse-mgr/creating-calculated-columns.md)
* [集計列の種類](../data-warehouse-mgr/calc-column-types.md)
* [注文お  [!DNL Google ECommerce]  び顧客データを使用したディメンションの作成](../data-warehouse-mgr/bldg-google-ecomm-dim.md)
