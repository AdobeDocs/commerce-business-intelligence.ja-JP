---
title: SQL クエリの最適化
description: SQL クエリを最適化する方法を説明します。
exl-id: 2782c707-6a02-4e5d-bfbb-eff20659fbb2
role: Admin, Data Architect, Data Engineer, User
feature: Data Integration, Data Import/Export, Data Warehouse Manager
source-git-commit: adb7aaef1cf914d43348abf5c7e4bec7c51bed0c
workflow-type: tm+mt
source-wordcount: '769'
ht-degree: 0%

---

# SQL クエリを最適化

この [!DNL SQL Report Builder] を使用すると、これらのクエリに対して、いつでもクエリを実行および繰り返すことができます。 これは、作成した列やレポートの更新が必要な場合に、更新サイクルの終了を待たずにクエリを変更する必要がある場合に便利です。

クエリの実行前に、 [[!DNL Commerce Intelligence] 推定コスト](https://experienceleague.adobe.com/docs/commerce-knowledge-base/kb/troubleshooting/miscellaneous/sql-queries-explain-cost-errors.html). コストは、クエリの実行に必要な時間とリソースの数を考慮します。 そのコストが高すぎると見なされる場合、または返される行数が超過する場合 [!DNL Commerce Intelligence] 制限により、クエリが失敗します。 クエリ用 [Data Warehouse](../data-analyst/data-warehouse-mgr/tour-dwm.md)Adobeでは、可能な限り効率的なクエリを記述できるように、次のことをお勧めします。

## SELECT の使用またはすべての列の選択

すべての列を選択しても、クエリがタイムリーで簡単に実行されるわけではありません。 を使用するクエリ `SELECT *` 特にテーブルに多くの列がある場合、実行に時間がかかる場合があります。

そのため、Adobeではを使用しないことをお勧めします `SELECT *` 可能な限り、必要な列のみを含めます。

| **代わりに…** | **試してみる！** |
|-----|-----|
| ![](../../mbi/assets/Select_all_1.png) | ![](../../mbi/assets/Select_all_2.png) |

{style="table-layout:auto"}

## 完全外部結合の使用

外部結合では、結合する両方のテーブル全体が選択されるので、クエリの計算コストが増加します。 つまり、クエリの実行に時間がかかり、結果が返されるまで実行制限より長くかかる可能性があるので、クエリが失敗する可能性が高くなります。

このタイプの結合を使用する代わりに、内部結合または左結合部の使用を検討してください。 内部結合は、テーブル間に列による一致がある場合にのみ結果を返します（例： `order_id` はの両方に典型的なものです `customers` および `orders` テーブル）に保存します。 左結合は、左（最初）のテーブルのすべての結果と、右（2 番目）のテーブルの一致する結果を返します。

完全外部結合クエリを書き換える方法を次に示します。

| **代わりに…** | **試してみる！** |
|-----|-----|
| ![](../../mbi/assets/Full_Outer_Join_1.png) | ![](../../mbi/assets/Full_Outer_Join_2.png) |

{style="table-layout:auto"}

これらのクエリは、使用する JOIN のタイプを除き、すべての点で同一です。

## 複数の結合の使用

クエリには複数の結合を含めることができますが、クエリのコストが上昇する可能性があることに注意してください。 コストのしきい値に達しないようにするために、Adobeでは、可能な限り複数の結合を避けることをお勧めします。

## フィルターの使用

可能な限りフィルターを使用します。 `WHERE` および `HAVING` 句は、結果をフィルタリングして、本当に必要なデータのみを提供します。

## JOIN 句でのフィルタの使用

結合を実行するときにフィルタを使用する場合は、結合の両方のテーブルに必ずフィルタを適用してください。 冗長になっても、これによりクエリの計算コストが削減され、実行時間が短縮されます。

| **代わりに…** | **試してみる！** |
|-----|-----|
| ![](../../mbi/assets/Join_filters_1.png) | ![](../../mbi/assets/Join_filters_2.png) |

{style="table-layout:auto"}

## 演算子の使用

クエリを記述する場合は、可能な限り低コストの演算子の使用を検討してください。 すべてのクエリには計算コストがあり、クエリを構成する関数、演算子、フィルターによって決定されます。 一部の演算子は計算作業が少なくて済み、他の演算子よりもコストが低くなります。

比較演算子（>、&lt;、=など）は最も費用が少なく、その後に [いいね。 AND POSIX 演算子と同様](https://www.postgresql.org/docs/9.5/functions-matching.html) これは最も高価な演算子です。

## EXISTS と IN の使用

使用 `EXISTS` 対 `IN` 返そうとしている結果のタイプによって異なります。 1 つの値のみを目的とする場合は、 `EXISTS` 句の代わり `IN`. `IN` を、コンマ区切り値のリストと共に使用すると、クエリの計算コストが増加します。

条件 `IN` クエリが実行されたら、システムはまずサブクエリ（ `IN` ステートメント）に含まれる場合は、で指定された関係に基づくクエリ全体が返されます。 `IN` ステートメント。 `EXISTS` は、クエリを複数回実行する必要がないので、はるかに効率的です。クエリで指定された関係を確認する際に、true/false 値が返されます。

簡単に言えば、システムは使用するときほど処理する必要はありません `EXISTS`.

| **代わりに…** | **試してみる！** |
|-----|-----|
| ![](../../mbi/assets/Exists_1.png) | ![](../../mbi/assets/Exists_2.png) |

{style="table-layout:auto"}

## 並べ替え順の使用

`ORDER BY` は SQL の高コストな関数で、クエリのコストを大幅に増やす可能性があります。 クエリの説明コストが高すぎるというエラーメッセージが表示された場合は、クエリを削除してみてください `ORDER BY`必要でない限り、クエリからを選択します。

そんなことは言うまでもない `ORDER BY` は使用できません。必要な場合にのみ使用する必要があります。

## Group BY と ORDER BY の使用

このアプローチが目的に合わない場合もあります。 一般的なルールは、 `GROUP BY` および `ORDER BY`の場合、両方の句の列を同じ順序で配置する必要があります。 例：

| **代わりに…** | **試してみる！** |
|-----|-----|
| ![](../../mbi/assets/Group_by_2.png) | ![](../../mbi/assets/Group_by_1.png) |

{style="table-layout:auto"}

## まとめ

SQL の書き方を学ぶ（そして効率的に書く）最善の方法は、試行錯誤を通じることです。 最適なレポートを見つけるには、SQL エディターのみを使用して、いくつかのレポートを再作成してみてください。
