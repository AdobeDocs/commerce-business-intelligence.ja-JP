---
title: SQL クエリの最適化
description: SQL クエリを最適化する方法を説明します。
exl-id: 2782c707-6a02-4e5d-bfbb-eff20659fbb2
role: Admin, Data Architect, Data Engineer, User
feature: Data Integration, Data Import/Export, Data Warehouse Manager
source-git-commit: acc152709c7c66f387f4eded9e6c1c646a83af35
workflow-type: tm+mt
source-wordcount: '826'
ht-degree: 0%

---

# SQL クエリを最適化

[!DNL SQL Report Builder] を使用すると、クエリを必要に応じて実行および変更できます。 この機能は、更新サイクルが完了するのを待ってから列またはレポートを修正する代わりに、クエリをすぐに更新する必要がある場合に役立ちます。

クエリを実行する前に、は [[!DNL Commerce Intelligence]  コストを見積もります &#x200B;](https://experienceleague.adobe.com/docs/commerce-knowledge-base/kb/troubleshooting/miscellaneous/sql-queries-explain-cost-errors.html?lang=ja)。 コストは、クエリの実行に必要な時間とリソースの数を考慮します。 そのコストが高すぎると見なされる場合や、返される行の数が [!DNL Commerce Intelligence] の制限を超える場合、クエリは失敗します。 Adobeで可能な限り効率的なクエリを記述できるように、[Data Warehouse](../data-analyst/data-warehouse-mgr/tour-dwm.md) に対してクエリを実行する場合は、次の操作をお勧めします。

## SELECT の使用またはすべての列の選択

すべての列を選択しても、クエリがタイムリーで簡単に実行されるわけではありません。 `SELECT *` を使用するクエリは、特にテーブルに多くの列がある場合、実行に非常に時間がかかる場合があります。

このため、Adobeでは、可能な限り `SELECT *` を使用せず、必要な列のみを含めることをお勧めします。

| **代わりに…** | **試してみる** |
|-----|-----|
| ![SELECT アスタリスクを使用した SQL クエリ &#x200B;](../../mbi/assets/Select_all_1.png) | ![&#x200B; 特定の列を選択する SQL クエリ &#x200B;](../../mbi/assets/Select_all_2.png) |

{style="table-layout:auto"}

## 完全外部結合の使用

外部結合では、結合する両方のテーブル全体が選択されるので、クエリの計算コストが増加します。 つまり、クエリの実行に時間がかかり、結果が返されるまで実行制限より長くかかる可能性があるので、クエリが失敗する可能性が高くなります。

このタイプの結合を使用する代わりに、内部結合または左結合部の使用を検討してください。 内部結合は、テーブル間に列による一致がある場合（たとえば、一般的な `order_id` とテーブルの両方に `customers` が存在する場合）にのみ結果 `orders` 返します。 左結合は、左（最初）のテーブルのすべての結果と、右（2 番目）のテーブルの一致する結果を返します。

完全外部結合クエリを書き換える方法を次に示します。

| **代わりに…** | **試してみる** |
|-----|-----|
| ![&#x200B; 完全外部結合を含む SQL クエリ &#x200B;](../../mbi/assets/Full_Outer_Join_1.png) | ![&#x200B; 最適化結合を使用した SQL クエリ &#x200B;](../../mbi/assets/Full_Outer_Join_2.png) |

{style="table-layout:auto"}

これらのクエリは、使用する JOIN のタイプを除き、すべての点で同一です。

## 複数の結合の使用

クエリには複数の結合を含めることができますが、クエリのコストが上昇する可能性があることに注意してください。 コストのしきい値に達しないようにするために、Adobeでは、可能な限り複数の結合を避けることをお勧めします。

## フィルターの使用

可能な限りフィルターを使用します。 句 `WHERE` と `HAVING` は、結果をフィルタリングし、本当に必要なデータのみを提供します。

## JOIN 句でのフィルタの使用

結合を実行するときにフィルタを使用する場合は、結合の両方のテーブルに必ずフィルタを適用してください。 冗長になっても、これによりクエリの計算コストが削減され、実行時間が短縮されます。

| **代わりに…** | **試してみる** |
|-----|-----|
| ![WHERE 句フィルターを含む SQL クエリ &#x200B;](../../mbi/assets/Join_filters_1.png) | ![ON 句フィルターを使用した SQL クエリ &#x200B;](../../mbi/assets/Join_filters_2.png) |

{style="table-layout:auto"}

## 演算子の使用

クエリを記述する場合は、可能な限り低コストの演算子の使用を検討してください。 すべてのクエリには計算コストがあり、クエリを構成する関数、演算子、フィルターによって決定されます。 一部の演算子は計算作業が少なくて済み、他の演算子よりもコストが低くなります。

比較演算子（>、&lt;、=など）は最もコストが低く、その後に [LIKE が続きます。 最もコストのかかる演算子である AND](https://www.postgresql.org/docs/9.5/functions-matching.html)POSIX 演算子に似ています。

## EXISTS と IN の使用

`EXISTS` と `IN` のどちらを使用するかは、返そうとしている結果のタイプによって異なります。 1 つの値のみを対象とする場合は、`EXISTS` の代わりに `IN` 句を使用します。 `IN` は、コンマ区切り値のリストと共に使用され、クエリの計算コストを増加させます。

クエリ `IN` 実行する場合、システムはまずサブクエリ（`IN` ステートメント）を処理し、次に `IN` ステートメントで指定された関係に基づいてクエリ全体を処理する必要があります。 `EXISTS` クエリは、クエリを複数回実行する必要がないので、はるかに効率的です。クエリで指定された関係を確認する際に、true/false 値が返されます。

簡単に言えば、システムは `EXISTS` を使用するときほど処理する必要はありません。

| **代わりに…** | **試してみる** |
|-----|-----|
| ![NULL チェック付きの LEFT JOIN を使用する SQL クエリ &#x200B;](../../mbi/assets/Exists_1.png) | ![EXISTS 句を使用した SQL クエリ &#x200B;](../../mbi/assets/Exists_2.png) |

{style="table-layout:auto"}

## 並べ替え順の使用

`ORDER BY` 関数は SQL ではコストが高く、クエリのコストを大幅に増やす可能性があります。 クエリの説明コストが高すぎるというエラーメッセージが表示された場合は、必要でない限り、クエリから `ORDER BY` を削除してみてください。

これは `ORDER BY` を使用できないとは言わないわけではなく、必要な場合にのみ使用する必要があります。

## Group BY と ORDER BY の使用

このアプローチが目的に合わない場合もあります。 `GROUP BY` と `ORDER BY` を使用する場合は、両方の句の列を同じ順序で配置する必要があるという原則があります。 例：

| **代わりに…** | **試してみる** |
|-----|-----|
| ![GROUP BY BEFORE フィルターを使用した SQL クエリ &#x200B;](../../mbi/assets/Group_by_2.png) | ![GROUP BY の前にフィルターを含む SQL クエリ &#x200B;](../../mbi/assets/Group_by_1.png) |

{style="table-layout:auto"}

## まとめ

SQL の書き方を学ぶ（そして効率的に書く）最善の方法は、試行錯誤を通じることです。 最適なレポートを見つけるには、SQL エディターのみを使用して、いくつかのレポートを再作成してみてください。
